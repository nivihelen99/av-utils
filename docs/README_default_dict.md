# `std_ext::defaultdict<Key, Value, DefaultFactory, ...>`

## Overview

The `std_ext::defaultdict` class (`default_dict.h`) is a C++ template class that behaves like `std::unordered_map` but with a special feature: if you try to access an element using `operator[]` with a key that is not already in the dictionary, the key is automatically inserted with a default value. This default value is generated by a "default factory" function provided during construction or set later.

This behavior is similar to Python's `collections.defaultdict` and is particularly useful for scenarios like counting, grouping items into collections, or initializing complex nested structures on demand.

## Template Parameters

-   `Key`: The type of the keys.
-   `Value`: The type of the values.
-   `DefaultFactory`: A callable type (e.g., lambda, function pointer, functor) that takes no arguments and returns a `Value`. This factory is invoked to create default values. Defaults to `std::function<Value()>`, which, if default-constructed, might require `Value` to be default-constructible if no factory is explicitly provided.
-   `Hash`, `KeyEqual`, `Allocator`: Standard template parameters for `std::unordered_map`, allowing customization of hashing, equality comparison, and memory allocation.

## Key Features

-   **Automatic Default Value Insertion:** When accessing a key via `operator[]` that does not exist, the key is inserted with a value generated by the `default_factory_`, and a reference to this new value is returned.
-   **Customizable Default Factory:** The mechanism for generating default values is user-configurable via the `DefaultFactory` template parameter and constructor arguments.
-   **`std::unordered_map` Compatibility:** Aims to provide a largely compatible interface with `std::unordered_map` for common operations (iteration, lookup, modifiers, capacity, etc.).
-   **Helper Factories:** Provides `std_ext::default_factory<Value>()` (for default construction), `std_ext::zero_factory<Value>()` (for zero-initialization if `Value` is constructible from `int`), and `std_ext::string_factory()` (for empty strings) to simplify common use cases.
-   **`get(key)` Method:** A `const` method to retrieve a value if the key exists, or a default-generated value if it doesn't, *without* modifying the dictionary.

## Public Interface Highlights

### Core `operator[]` Behavior
```cpp
Value& operator[](const Key& key);
Value& operator[](Key&& key);
```
If `key` is not found, `default_factory_()` is called, the result is inserted with `key`, and a reference to the new value is returned. Otherwise, a reference to the existing value is returned.

### Constructors
Provides a wide range of constructors mirroring `std::unordered_map`, each allowing an optional `DefaultFactory` argument. Examples:
```cpp
// With a default factory (e.g., for Value that's default constructible)
defaultdict<std::string, int> counter1; // Uses default-constructed DefaultFactory

// With a specific factory (e.g., lambda returning 0 for int)
defaultdict<std::string, int> counter2([](){ return 0; });
// Or using a helper:
defaultdict<std::string, int> counter3(std_ext::zero_factory<int>());

// From initializer list, with a factory for list values
auto list_factory = [](){ return std::vector<std::string>{}; };
defaultdict<int, std::vector<std::string>> grouped_items(list_factory);
```

### Other Key Methods
-   **`Value& at(const Key& key)` / `const Value& at(const Key& key) const`**: Standard map behavior; throws `std::out_of_range` if key not found (does not use default factory).
-   **`Value get(const Key& key) const`**: Returns the value for `key` if present; otherwise, returns `default_factory_()` *without inserting*.
-   **`const DefaultFactory& get_default_factory() const noexcept`**: Retrieves the current default factory.
-   **`void set_default_factory(F&& factory)`**: Changes the default factory.
-   Most other methods (`begin`, `end`, `size`, `empty`, `insert`, `erase`, `find`, `contains`, etc.) delegate to the underlying `std::unordered_map`.

## Helper Factories (in `std_ext` namespace)
-   **`template<typename Value> auto default_factory()`**: Returns a lambda `[]() -> Value { return Value{}; }`.
-   **`template<typename Value> auto zero_factory()`**: Returns a lambda `[]() -> Value { return Value{0}; }`.
-   **`inline auto string_factory()`**: Returns a lambda `[]() -> std::string { return std::string{}; }`.

## Usage Examples

(Based on `examples/use_default_dict.cpp`)

### Counting Frequencies

```cpp
#include "default_dict.h"
#include <iostream>
#include <string>
#include <vector>

int main() {
    // defaultdict for counting, default value for int is 0
    std_ext::defaultdict<std::string, int> word_counts(std_ext::zero_factory<int>());

    std::vector<std::string> words = {"apple", "banana", "apple", "orange", "apple", "banana"};
    for (const std::string& word : words) {
        word_counts[word]++; // Accessing new keys creates them with count 0, then increments
    }

    for (const auto& pair : word_counts) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    // Example output:
    // orange: 1
    // banana: 2
    // apple: 3
    std::cout << "grape count: " << word_counts["grape"] << std::endl; // Accesses "grape", initializes to 0
}
```

### Grouping Items into Collections

```cpp
#include "default_dict.h"
#include <iostream>
#include <string>
#include <vector>
#include <list> // Example with list as value

int main() {
    // defaultdict where values are lists of integers
    auto list_factory = []() { return std::list<int>{}; };
    std_ext::defaultdict<std::string, std::list<int>, decltype(list_factory)> groups(list_factory);

    groups["groupA"].push_back(1);
    groups["groupB"].push_back(10);
    groups["groupA"].push_back(2);
    groups["groupB"].push_back(20);
    groups["groupA"].push_back(3);
    groups["groupC"]; // Creates an empty list for "groupC"

    for (const auto& [group_name, item_list] : groups) {
        std::cout << group_name << ": ";
        for (int item : item_list) {
            std::cout << item << " ";
        }
        std::cout << std::endl;
    }
    // Example output:
    // groupC:
    // groupB: 10 20
    // groupA: 1 2 3
}
```

### Using `get()` for Safe Read-Only Access with Defaults

```cpp
#include "default_dict.h"
#include <iostream>
#include <string>

int main() {
    const std_ext::defaultdict<std::string, int> config(
        std_ext::zero_factory<int>(), // Default factory
        {{"timeout", 30}, {"retries", 3}} // Initializer list
    );

    std::cout << "Timeout: " << config.get("timeout") << std::endl;     // 30
    std::cout << "Retries: " << config.get("retries") << std::endl;     // 3
    std::cout << "Max Users: " << config.get("max_users") << std::endl; // 0 (from factory, not inserted)

    std::cout << "Config size after get: " << config.size() << std::endl; // Still 2, "max_users" was not added
}
```

## Dependencies
- `<unordered_map>`
- `<functional>` (for `std::function` as default factory type)
- `<type_traits>`
- `<utility>`
- `<memory>` (for `std::allocator_traits`)

`std_ext::defaultdict` simplifies code by removing the need to manually check for key existence before insertion or initialization when accumulating or grouping data.
